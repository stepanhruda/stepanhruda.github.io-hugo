<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Stepan.Technology</title>
    <description></description>
    <link>http://www.stepan.technology/</link>
    <atom:link href="http://www.stepan.technology/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Part 5: Prototyping transitions</title>
        <description>&lt;blockquote&gt;
&lt;p&gt;This article is part of the &lt;a href=&quot;../transition-with-stptransitions/&quot;&gt;Transition with STPTransitions&lt;/a&gt; series.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is rather a short article about a convenient way to use &lt;em&gt;STPTransition&lt;/em&gt; when prototyping. When playing around, it is often a hassle to create a separate class, go there and back and change the animation all the time.&lt;/p&gt;

&lt;p&gt;If you liked what you read here, &lt;a href=&quot;https://twitter.com/stepanhruda&quot;&gt;follow me on Twitter&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Thu, 05 Jun 2014 00:00:00 -0400</pubDate>
        <link>http://www.stepan.technology/articles/prototyping-transitions</link>
        <guid isPermaLink="true">http://www.stepan.technology/articles/prototyping-transitions</guid>
      </item>
    
      <item>
        <title>Part 4: Presented and child view controllers</title>
        <description>&lt;blockquote&gt;
&lt;p&gt;This article is part of the &lt;a href=&quot;../transition-with-stptransitions/&quot;&gt;Transition with STPTransitions&lt;/a&gt; series.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So far, we have only worked with transitions inside a &lt;em&gt;UINavigationController&lt;/em&gt;. iOS has two additional ways of switching between view controllers, though: presentation via &lt;em&gt;presentViewController:animated:completion:&lt;/em&gt; (with dismissal via &lt;em&gt;dismissViewController:animated:completion:&lt;/em&gt;), and containment, where the driver is &lt;em&gt;transitionFromViewController:toViewController:animations&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Good news, everyone: any &lt;em&gt;STPTransition&lt;/em&gt; you write works for all three types of transitions. In other words, you can reuse them in any of the provided methods.&lt;/p&gt;

&lt;h3&gt;Presentation&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;STPTransitions&lt;/em&gt; provides methods with signatures corresponding to UIKit&amp;#39;s. We can make the example from the &lt;a href=&quot;../gettin-interactive/&quot;&gt;previous article on interactivity&lt;/a&gt; work with one &lt;em&gt;duh&lt;/em&gt; change:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;instead of &lt;em&gt;push&lt;/em&gt; and &lt;em&gt;pop&lt;/em&gt; methods, we use &lt;em&gt;present&lt;/em&gt; and &lt;em&gt;dismiss&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;- (void)setUpForwardTransition:(STPTransition *)transition {
    ...

    __weak __typeof(self) weakSelf = self;
    transition.onGestureTriggered = ^(STPTransition *transition, UIGestureRecognizer *recognizer) {
        [weakSelf presentViewController:[STPSecondViewController new]
                        usingTransition:transition
                           onCompletion:nil];
//      [self.navigationController pushViewController:[STPSecondViewController new]
//                                    usingTransition:transition];
    };
    ...
}

- (void)setUpReverseTransition:(STPTransition *)transition {
    __weak __typeof(self) weakSelf = self;
    transition.onGestureTriggered = ^(STPTransition *transition, UIGestureRecognizer *recognizer) {
        [weakSelf dismissViewControllerAnimated:YES completion:nil];
//      [weakSelf popViewControllerAnimated:YES];
    };
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;(also, we can completely get rid of the navigation controller, it&amp;#39;s not needed for this setup)&lt;/li&gt;
&lt;/ul&gt;

&lt;div&gt;&lt;img class=&quot;centered&quot; src=&quot;/media/2014-06-04-presented-and-child-view-controllers/present-interactive.gif&quot; alt=&quot;Ta-dah! The exact same transition using a completely different mechanism.&quot; /&gt;
&lt;blockquote style=&quot;border-left: 10px solid #D5D5D5;&quot;&gt;Ta-dah! The exact same transition using a completely different mechanism.&lt;/blockquote&gt; &lt;/div&gt;

&lt;h3&gt;Containment&lt;/h3&gt;

&lt;p&gt;// TODO: Make interactive transitions between child view controllers work&lt;/p&gt;

&lt;p&gt;Next part: &lt;a href=&quot;../prototyping-transitions&quot;&gt;Prototyping transitions&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If you liked what you read here, &lt;a href=&quot;https://twitter.com/stepanhruda&quot;&gt;follow me on Twitter&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Wed, 04 Jun 2014 00:00:00 -0400</pubDate>
        <link>http://www.stepan.technology/articles/presented-and-child-view-controllers</link>
        <guid isPermaLink="true">http://www.stepan.technology/articles/presented-and-child-view-controllers</guid>
      </item>
    
      <item>
        <title>Part 3: Gettin&#39; interactive</title>
        <description>&lt;blockquote&gt;
&lt;p&gt;This article is part of the &lt;a href=&quot;../transition-with-stptransitions/&quot;&gt;Transition with STPTransitions&lt;/a&gt; series.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In the &lt;a href=&quot;../putting-a-transition-into-reverse-gear/&quot;&gt;second article&lt;/a&gt; we made our transition able to animate in both directions. However, the user usually gets a much better experience if a transition tracks their finger movement instead of animating in a chunk. If done correctly, it makes them feel they are in charge of what&amp;#39;s happening on screen, allows them to cancel the animation (and go back), and other good things.&lt;/p&gt;

&lt;h3&gt;How to STPTransition&lt;/h3&gt;

&lt;p&gt;A transition becomes interactive when it gets attached to a gesture recognizer (there&amp;#39;s a category adding a &lt;em&gt;stp_transition&lt;/em&gt; property). On top of that, there are a handful of block properties on the &lt;em&gt;STPTransition&lt;/em&gt; instance that we need to implement to achieve finger tracking.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@property (nonatomic, copy) void (^onGestureTriggered)(STPTransition *transition, UIGestureRecognizer *recognizer);

@property (nonatomic, copy) CGFloat (^completionPercentageForGestureRecognizerState)(UIGestureRecognizer *recognizer);

@property (nonatomic, copy) BOOL (^shouldCompleteTransitionOnGestureEnded)(UIGestureRecognizer *recognizer, CGFloat completion);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Gesture recognizer&lt;/h3&gt;

&lt;p&gt;Let&amp;#39;s start with creating a transition and attaching it to a gesture recognizer. Assuming the user can initiate the gesture anywhere on screen, we&amp;#39;ll just add the recognizer to our application&amp;#39;s &lt;em&gt;keyWindow&lt;/em&gt;. For the recognizer, we&amp;#39;ll use &lt;em&gt;UIPanGestureRecognizer&lt;/em&gt;, because we want to react do dragging.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;- (void)viewDidLoad {
    [super viewDidLoad];
    ...
    [self setUpGestureRecognizer];
}

- (void)setUpGestureRecognizer {
    STPTransition *transition = [STPRotateFadeTransition new];
    transition.reverseTransition = [STPRotateFadeTransition new];

    [self addGestureRecognizerForTransition:transition];
}

- (void)addGestureRecognizerForTransition:(STPTransition *)transition {
    UIPanGestureRecognizer *recognizer = [UIPanGestureRecognizer new];
    [UIApplication.sharedApplication.keyWindow addGestureRecognizer:recognizer];
    recognizer.stp_transition = transition;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Important note: You shouldn&amp;#39;t be using this gesture recognizer for anything else. It also gets automatically removed from its view after a successful transition. Keeping it attached would mean trouble.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;Triggering the gesture&lt;/h3&gt;

&lt;p&gt;In &lt;em&gt;onGestureTriggered&lt;/em&gt; we generally want to tell the controller in what way we&amp;#39;d like the transition to happen. This is the equivalent of using the transition without any interactivity (e.g. pushing in a button action method), except it is wrapped in a conditional block that only gets triggered by the gesture.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;__weak __typeof(self) weakSelf = self;
transition.onGestureTriggered = ^(STPTransition *transition, UIGestureRecognizer *recognizer) {
    [weakSelf.navigationController pushViewController:[STPSecondViewController new]
                                      usingTransition:transition];
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Note: Technically, your controller could own your transition (it could own a view that owns the recognizer that owns the transition), so we should use &lt;strong&gt;&lt;em&gt;weakSelf&lt;/em&gt;&lt;/strong&gt; to be safe here.&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;Tracking the gesture&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;completionPercentageForGestureRecognizerState&lt;/em&gt; does the heavy lifting (if you can even call it heavy lifting). It gives us the recognizer&amp;#39;s state and we need to reply with how it corresponds to the progress of the animation on a scale from 0 (initial state) to 1 (animated all the way).&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s say that to get to 100%, the user has to slide halfway across the screen. In our case, we also only track movement on the &lt;em&gt;x&lt;/em&gt; axis, since our animation doesn&amp;#39;t happen on the &lt;em&gt;y&lt;/em&gt; axis at all.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;transition.completionPercentageForGestureRecognizerState = ^CGFloat (UIGestureRecognizer *recognizer) {
    UIPanGestureRecognizer *panGestureRecognizer = (UIPanGestureRecognizer *)recognizer;
    CGPoint translation = [panGestureRecognizer translationInView:recognizer.view];
    CGFloat completion = (2.0f * -translation.x) / CGRectGetWidth(recognizer.view.frame);
    return completion;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Ending the gesture&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;shouldCompleteTransitionOnGestureEnded&lt;/em&gt; asks us what happens when a detected gesture ends. We have two choices – either we return &lt;em&gt;YES&lt;/em&gt; and the transition finishes and goes to the &lt;em&gt;to&lt;/em&gt; view controller, or we return &lt;em&gt;NO&lt;/em&gt;, the transition gets cancelled and we return to where we started (the &lt;em&gt;from&lt;/em&gt; view controller).&lt;/p&gt;

&lt;p&gt;There are a number of smart fine-tunings you can do here, but for simplicity&amp;#39;s sake, we&amp;#39;ll finish the transition if the user dragged more than 40% of the way.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;transition.shouldCompleteTransitionOnGestureEnded = ^BOOL (UIGestureRecognizer *recognizer, CGFloat completion) {
    return completion &amp;gt; 0.4f;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Checkpoint&lt;/h3&gt;

&lt;p&gt;Let&amp;#39;s see what we have so far.&lt;/p&gt;

&lt;div&gt;&lt;img class=&quot;centered&quot; src=&quot;/media/2014-06-03-gettin-interactive/interactive-forward.gif&quot; alt=&quot;&quot; /&gt;
 &lt;/div&gt;

&lt;p&gt;Not bad for a couple of lines of code, right? If you stop dragging &amp;lt;40% of the way, the controller automatically returns where it started. Otherwise, the transition gets finished.&lt;/p&gt;

&lt;p&gt;However, if we go there and back and try to use the gesture again, it won&amp;#39;t work.&lt;/p&gt;

&lt;div&gt;&lt;img class=&quot;centered&quot; src=&quot;/media/2014-06-03-gettin-interactive/interactive-forward-broken.gif&quot; alt=&quot;Why u no work?&quot; /&gt;
&lt;blockquote style=&quot;border-left: 10px solid #D5D5D5;&quot;&gt;Why u no work?&lt;/blockquote&gt; &lt;/div&gt;

&lt;p&gt;The gesture recognizer gets removed after it&amp;#39;s been used for a successful transition, remember? It is easy enough to track down when we return to the first screen again, and repeat the whole gesture recognizer dance.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;- (void)setUpGestureRecognizer {
    STPTransition *transition = [STPRotateFadeTransition new];
    transition.reverseTransition = [STPRotateFadeTransition new];

    [self setUpForwardTransition:transition];
    [self setUpReverseTransition:transition.reverseTransition];
}

- (void)setUpReverseTransition:(STPTransition *)transition {
    transition.onCompletion = ^(STPTransition *transition, BOOL transitionWasCompleted) {
        if (transitionWasCompleted) {
            [weakSelf setUpGestureRecognizer];
        }
    };
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Interacting back&lt;/h3&gt;

&lt;p&gt;For our final trick, we&amp;#39;ll make the gesture work for the reverse transition, so the user can freely drag there and back from either screen. It&amp;#39;s almost like if they were dragging a scroll view, while they are in fact switching between controllers in a navigation stack!&lt;/p&gt;

&lt;p&gt;We extend our existing &lt;em&gt;setUpReverseTransition:&lt;/em&gt; method with a setup very similar to what we already have for the forward transition, with two small differences:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;when the gesture gets triggered, we want to pop the controller, not push it&lt;/li&gt;
&lt;li&gt;the gesture recognizer&amp;#39;s translation is now a positive value (user&amp;#39;s dragging the other way), so we lose the negative sign&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;- (void)setUpReverseTransition:(STPTransition *)transition {
    __weak __typeof(self) weakSelf = self;
    transition.onGestureTriggered = ^(STPTransition *transition, UIGestureRecognizer *recognizer) {
        [weakSelf.navigationController popViewControllerAnimated:YES];
    };

    transition.completionPercentageForGestureRecognizerState = ^CGFloat (UIGestureRecognizer *recognizer) {
        UIPanGestureRecognizer *panGestureRecognizer = (UIPanGestureRecognizer *)recognizer;
        CGPoint translation = [panGestureRecognizer translationInView:recognizer.view];
        CGFloat completion = (2.0f * translation.x) / CGRectGetWidth(recognizer.view.frame);
        return completion;
    };

    transition.shouldCompleteTransitionOnGestureEnded = ^BOOL (UIGestureRecognizer *recognizer, CGFloat completion) {
        return completion &amp;gt; 0.4f;
    };

    transition.onCompletion = ^(STPTransition *transition, BOOL transitionWasCompleted) {
        if (transitionWasCompleted) {
            [weakSelf setUpGestureRecognizer];
        }
    };
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Additionaly, we need to make sure a gesture recognizer that can track the view exists. It seems like a good idea to add it when the first transition finishes, because that&amp;#39;s the first moment the user could possibly drag back.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;- (void)setUpForwardTransition:(STPTransition *)transition {
    ...
    transition.onCompletion = ^(STPTransition *transition, BOOL transitionWasCompleted) {
        if (transitionWasCompleted) {
            [weakSelf addGestureRecognizerForTransition:transition.reverseTransition];
        }
    };

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;&lt;img class=&quot;centered&quot; src=&quot;/media/2014-06-03-gettin-interactive/interactive-both-ways.gif&quot; alt=&quot;Finally we can spin it properly!&quot; /&gt;
&lt;blockquote style=&quot;border-left: 10px solid #D5D5D5;&quot;&gt;Finally we can spin it properly!&lt;/blockquote&gt; &lt;/div&gt;

&lt;p&gt;Next part: &lt;a href=&quot;../presented-and-child-view-controllers/&quot;&gt;Presented and child view controllers&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If you liked what you read here, &lt;a href=&quot;https://twitter.com/stepanhruda&quot;&gt;follow me on Twitter&lt;/a&gt;.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;All written view controller code for reference:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;- (void)viewDidLoad {
    [super viewDidLoad];
    ...
    [self setUpGestureRecognizer];
}

- (void)setUpGestureRecognizer {
    STPTransition *transition = [STPRotateFadeTransition new];
    transition.reverseTransition = [STPRotateFadeTransition new];

    [self setUpForwardTransition:transition];
    [self setUpReverseTransition:transition.reverseTransition];
}

- (void)setUpForwardTransition:(STPTransition *)transition {
    [self addGestureRecognizerForTransition:transition];

    __weak __typeof(self) weakSelf = self;
    transition.onGestureTriggered = ^(STPTransition *transition, UIGestureRecognizer *recognizer) {
        [weakSelf.navigationController pushViewController:[STPSecondViewController new]
                                          usingTransition:transition];
    };

    transition.completionPercentageForGestureRecognizerState = ^CGFloat (UIGestureRecognizer *recognizer) {
        UIPanGestureRecognizer *panGestureRecognizer = (UIPanGestureRecognizer *)recognizer;
        CGPoint translation = [panGestureRecognizer translationInView:recognizer.view];
        CGFloat completion = (2.0f * -translation.x) / CGRectGetWidth(recognizer.view.frame);
        return completion;
    };

    transition.shouldCompleteTransitionOnGestureEnded = ^BOOL (UIGestureRecognizer *recognizer, CGFloat completion) {
        return completion &amp;gt; 0.4f;
    };

    transition.onCompletion = ^(STPTransition *transition, BOOL transitionWasCompleted) {
        if (transitionWasCompleted) {
            [weakSelf addGestureRecognizerForTransition:transition.reverseTransition];
        }
    };
}

- (void)setUpReverseTransition:(STPTransition *)transition {
    __weak __typeof(self) weakSelf = self;
    transition.onGestureTriggered = ^(STPTransition *transition, UIGestureRecognizer *recognizer) {
        [weakSelf.navigationController popViewControllerAnimated:YES];
    };

    transition.completionPercentageForGestureRecognizerState = ^CGFloat (UIGestureRecognizer *recognizer) {
        UIPanGestureRecognizer *panGestureRecognizer = (UIPanGestureRecognizer *)recognizer;
        CGPoint translation = [panGestureRecognizer translationInView:recognizer.view];
        CGFloat completion = (2.0f * translation.x) / CGRectGetWidth(recognizer.view.frame);
        return completion;
    };

    transition.shouldCompleteTransitionOnGestureEnded = ^BOOL (UIGestureRecognizer *recognizer, CGFloat completion) {
        return completion &amp;gt; 0.4f;
    };

    transition.onCompletion = ^(STPTransition *transition, BOOL transitionWasCompleted) {
        if (transitionWasCompleted) {
            [weakSelf setUpGestureRecognizer];
        }
    };
}

- (void)addGestureRecognizerForTransition:(STPTransition *)transition {
    UIPanGestureRecognizer *recognizer = [UIPanGestureRecognizer new];
    [UIApplication.sharedApplication.keyWindow addGestureRecognizer:recognizer];
    recognizer.stp_transition = transition;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        <pubDate>Tue, 03 Jun 2014 00:00:00 -0400</pubDate>
        <link>http://www.stepan.technology/articles/gettin-interactive</link>
        <guid isPermaLink="true">http://www.stepan.technology/articles/gettin-interactive</guid>
      </item>
    
      <item>
        <title>Part 2: Putting a transition in reverse gear</title>
        <description>&lt;blockquote&gt;
&lt;p&gt;This article is part of the &lt;a href=&quot;../transition-with-stptransitions/&quot;&gt;Transition with STPTransitions&lt;/a&gt; series.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In the &lt;a href=&quot;../pushing-a-transition/&quot;&gt;first article&lt;/a&gt;, we created a pretty snazzy transition when pushing view controllers. It&amp;#39;d be cool if we also animated in reverse when going back.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;STPTransiton&lt;/em&gt; has a &lt;strong&gt;reverseTransition&lt;/strong&gt; property, which you can specify when pushing. This way, any pushed view controller is agnostic of how it was presented and doesn&amp;#39;t have to worry about anything when going back.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;STPTransition *transition = [STPRotateFadeTransition new];
transition.reverseTransition = [STPRotateFadeTransition new];
[self.navigationController pushViewController:secondViewController
                              usingTransition:transition];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Note: STPTransition is a representation of a one-time transition between two view controllers. Don&amp;#39;t reuse the instances, simply create new ones. It&amp;#39;s cheap!&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;Wrong way&lt;/h3&gt;

&lt;p&gt;Unfortunately, only specifying a reverse transition is not enough right now. This is what happens when you simply add a reverse transition.&lt;/p&gt;

&lt;div&gt;&lt;img class=&quot;centered&quot; src=&quot;/media/2014-06-02-putting-transition-in-reverse-gear/wrong-way.gif&quot; alt=&quot;While looking cool, this is not what you usually want.&quot; /&gt;
&lt;blockquote style=&quot;border-left: 10px solid #D5D5D5;&quot;&gt;While looking cool, this is not what you usually want.&lt;/blockquote&gt; &lt;/div&gt;

&lt;p&gt;Of course it goes the wrong way! We never told anyone what the animation should look like when going in the other direction. It&amp;#39;s easy enough to spill the beans on that – we can modify our transition class to account for both going forwards and backwards.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Pro tip: We could of course create a separate transition class for the other direction. In most cases, the code is going to be so similar to the original class that one &lt;strong&gt;&lt;em&gt;STPTransition&lt;/em&gt;&lt;/strong&gt; can easily handle both directions and is much easier to maintain.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;Naming&lt;/h3&gt;

&lt;p&gt;Before we make the change, let&amp;#39;s make sure we are clear on the naming: &lt;em&gt;toView&lt;/em&gt; is always the view we&amp;#39;re trying to get to. &lt;em&gt;fromView&lt;/em&gt; is the view we&amp;#39;re starting with.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;first controller       second controller

                pushing
     fromView     -&amp;gt;       toView

                popping
      toView      &amp;lt;-      fromView
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Alpha&lt;/h3&gt;

&lt;p&gt;We don&amp;#39;t need to change anything about the &lt;em&gt;alpha&lt;/em&gt;s of the views at all: the newly appearing &lt;em&gt;toView&lt;/em&gt; goes from 0-&amp;gt;1, the disappearing &lt;em&gt;fromView&lt;/em&gt; goes 1-&amp;gt;0 when going in either direction. Not having to write any code is almost as rewarding as deleting code!&lt;/p&gt;

&lt;h3&gt;Rotation&lt;/h3&gt;

&lt;p&gt;When pushing, &lt;em&gt;fromView&lt;/em&gt; was rotating to the left, now we need it to rotate to the right. To figure out which way we&amp;#39;re going, we can leverage the &lt;strong&gt;&lt;em&gt;isReversed&lt;/em&gt;&lt;/strong&gt; property provided by &lt;em&gt;STPTransition&lt;/em&gt; and switch the rotation if it&amp;#39;s &lt;em&gt;YES&lt;/em&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;toView.layer.transform = !self.isReversed ? [self rotatedRightToX:offsetX] : [self rotatedLeftToX:offsetX];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Vice versa for the &lt;em&gt;toView&lt;/em&gt;. We need it to go to the right in case we&amp;#39;re going in reverse.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;fromView.layer.transform = !self.isReversed ? [self rotatedLeftToX:offsetX] : [self rotatedRightToX:offsetX];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Done and done&lt;/h3&gt;

&lt;p&gt;That&amp;#39;s it, we rotate in the other direction when going back. Those are all the changes we really need to do for our transition to work in both directions.&lt;/p&gt;

&lt;div&gt;&lt;img class=&quot;centered&quot; src=&quot;/media/2014-06-02-putting-transition-in-reverse-gear/reverse.gif&quot; alt=&quot;It works both for the default &lt; Back button and for our custom &lt;i&gt;one more time&lt;/i&gt; button.&quot; /&gt;
&lt;blockquote style=&quot;border-left: 10px solid #D5D5D5;&quot;&gt;It works both for the default &lt; Back button and for our custom &lt;i&gt;one more time&lt;/i&gt; button.&lt;/blockquote&gt; &lt;/div&gt;

&lt;h3&gt;Decoupling&lt;/h3&gt;

&lt;p&gt;Take a look at the implementation of the &lt;em&gt;one more time&lt;/em&gt; button&amp;#39;s action. It&amp;#39;s so dumb it could be on reality TV. This controller doesn&amp;#39;t have any transition-specific code at all!&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;- (void)backButtonTapped:(UIButton *)sender {
    [self.navigationController popViewControllerAnimated:YES];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Pro tip: The controller still knows it has a navigation controller. If we wanted to make it totally decoupled, we could implement an &lt;strong&gt;&lt;em&gt;onBackAction&lt;/em&gt;&lt;/strong&gt; block property. The presenting controller would then supply the block for the dimissal.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;Choosing your pop transition&lt;/h3&gt;

&lt;p&gt;Sometimes you might not want to be surfing the decoupling wave. You can hard-choose the popping transition using &lt;em&gt;-popViewControllerUsingTransition:&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[self.navigationController popViewControllerUsingTransition:[STPSlideUpTransition new]];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will result in a different transition when going back.&lt;/p&gt;

&lt;div&gt;&lt;img class=&quot;centered&quot; src=&quot;/media/2014-06-02-putting-transition-in-reverse-gear/reverse-slide.gif&quot; alt=&quot;&quot; /&gt;
 &lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Pro tip: If we pass in &lt;strong&gt;&lt;em&gt;nil&lt;/em&gt;&lt;/strong&gt;, the navigation controller will use the default iOS pop transition.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Next part: &lt;a href=&quot;../gettin-interactive/&quot;&gt;Gettin&amp;#39; interactive&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If you liked what you read here, &lt;a href=&quot;https://twitter.com/stepanhruda&quot;&gt;follow me on Twitter&lt;/a&gt;.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Updated transition&amp;#39;s code for reference:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;// STPRotateFadeTransition.h

@interface STPRotateFadeTransition : STPTransition

@end

// STPRotateFadeTransition.m

#import &amp;quot;STPRotateFadeTransition.h&amp;quot;

@implementation STPRotateFadeTransition

- (NSTimeInterval)transitionDuration {
    return 0.5f;
}

- (void)animateFromView:(UIView *)fromView
                 toView:(UIView *)toView
        inContainerView:(UIView *)containerView
    executeOnCompletion:(void (^)(BOOL))onCompletion {
    toView.alpha = 0.0f;

    CGFloat offsetX = CGRectGetWidth(containerView.bounds) / 2.5f;

    toView.layer.transform = !self.isReversed ? [self rotatedRightToX:offsetX] : [self rotatedLeftToX:offsetX];

    [containerView addSubview:toView];

    [UIView animateWithDuration:self.transitionDuration
                     animations:
     ^{
         fromView.alpha = 0.0f;
         toView.alpha = 1.0f;

         fromView.layer.transform = !self.isReversed ? [self rotatedLeftToX:offsetX] : [self rotatedRightToX:offsetX];
         toView.layer.transform = CATransform3DIdentity;
     }
                     completion:
     ^(BOOL finished) {
         onCompletion(finished);

         fromView.alpha = 1.0f;
         toView.alpha = 1.0f;

         fromView.layer.transform = CATransform3DIdentity;
         toView.layer.transform = CATransform3DIdentity;
     }];
}

- (CATransform3D)rotatedLeftToX:(CGFloat)offsetX {
    CATransform3D rotateNegatively = CATransform3DMakeRotation(-M_PI_2, 0, 1, 0);
    CATransform3D moveLeft = CATransform3DMakeTranslation(-offsetX, 0, 0);
    return CATransform3DConcat(rotateNegatively, moveLeft);
}

- (CATransform3D)rotatedRightToX:(CGFloat)offsetX {
    CATransform3D rotatePositively = CATransform3DMakeRotation(M_PI_2, 0, 1, 0);
    CATransform3D moveRight = CATransform3DMakeTranslation(offsetX, 0, 0);
    return CATransform3DConcat(rotatePositively, moveRight);
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        <pubDate>Mon, 02 Jun 2014 00:00:00 -0400</pubDate>
        <link>http://www.stepan.technology/articles/putting-a-transition-into-reverse-gear</link>
        <guid isPermaLink="true">http://www.stepan.technology/articles/putting-a-transition-into-reverse-gear</guid>
      </item>
    
      <item>
        <title>Part 1: Pushing a transition</title>
        <description>&lt;blockquote&gt;
&lt;p&gt;This article is part of the &lt;a href=&quot;../transition-with-stptransitions/&quot;&gt;Transition with STPTransitions&lt;/a&gt; series.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is the first of the couple of articles, where I am going to show how to write transitions in a straightforward way using &lt;a href=&quot;http://github.com/stepanhruda/STPTransitions&quot;&gt;STPTransitions&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Object rotate&lt;/h3&gt;

&lt;p&gt;Let&amp;#39;s say I want to build an &amp;quot;object rotate&amp;quot; transition, similar to the one in Keynote. Watch this.&lt;/p&gt;

&lt;div&gt;&lt;img class=&quot;centered&quot; src=&quot;/media/2014-06-01-pushing-a-transition/spin-slow.gif&quot; alt=&quot;A GIF is worth over 9000 words. This seems like a useful transition.&quot; /&gt;
&lt;blockquote style=&quot;border-left: 10px solid #D5D5D5;&quot;&gt;A GIF is worth over 9000 words. This seems like a useful transition.&lt;/blockquote&gt; &lt;/div&gt;

&lt;h3&gt;How to STPTransition&lt;/h3&gt;

&lt;p&gt;To create such a &lt;em&gt;STPTransition&lt;/em&gt;, we don&amp;#39;t have to do much: subclass &lt;em&gt;STPTransition&lt;/em&gt; and implement two methods.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;- (NSTimeInterval)transitionDuration;

- (void)animateFromView:(UIView *)fromView
                 toView:(UIView *)toView
        inContainerView:(UIView *)containerView
    executeOnCompletion:(void (^)(BOOL))onCompletion;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Obviously, the second method is what brings the meat home. But let&amp;#39;s get the duration out of the way first.&lt;/p&gt;

&lt;h3&gt;Duration&lt;/h3&gt;

&lt;p&gt;After doing a lot of difficult math, I decided our animation is going to last half a second.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;- (NSTimeInterval)transitionDuration {
    return 0.5f;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Note: The navigation bar automatically gets this duration when animating itself. We should also reuse it when animating the transition.&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;Animation&lt;/h3&gt;

&lt;p&gt;Onwards to explore the documentation and/or signature for the other method.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;- (void)animateFromView:(UIView *)fromView
                 toView:(UIView *)toView
        inContainerView:(UIView *)containerView
    executeOnCompletion:(void (^)(BOOL))onCompletion;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It gives us a &lt;em&gt;fromView&lt;/em&gt; and &lt;em&gt;toView&lt;/em&gt;. In our case the &lt;em&gt;fromView&lt;/em&gt; is going to be rotating and disappearing to the left; &lt;em&gt;toView&lt;/em&gt; is going to be appearing and rotating from the right.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;containerView&lt;/em&gt; is the superview in which the animation takes place. At the beginning of the transition, the &lt;em&gt;toView&lt;/em&gt; (which we&amp;#39;re trying to end up with) isn&amp;#39;t on screen yet. We need to add it to the &lt;em&gt;containerView&lt;/em&gt; when we want it to appear. We can do that right away, since there&amp;#39;s no delay for it to start appearing. Also, the &lt;em&gt;toView&lt;/em&gt; is hidden and rotated at the beginning of the animation. (Don&amp;#39;t worry about the transform too much; trust me, it rotates correctly.)&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;- (void)animateFromView:(UIView *)fromView
                 toView:(UIView *)toView
        inContainerView:(UIView *)containerView
    executeOnCompletion:(void (^)(BOOL))onCompletion {
    toView.alpha = 0.0f;

    CGFloat offsetX = CGRectGetWidth(containerView.bounds) / 2.5f;
    toView.layer.transform = [self rotatedRightToX:offsetX];

    [containerView addSubview:toView];

...

- (CATransform3D)rotatedRightToX:(CGFloat)offsetX {
    CATransform3D rotatePositively = CATransform3DMakeRotation(M_PI_2, 0, 1, 0);
    CATransform3D moveRight = CATransform3DMakeTranslation(offsetX, 0, 0);
    return CATransform3DConcat(rotatePositively, moveRight);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Having set up the inital state, now we can animate. The alphas of both the views change as if they were crossfading (&lt;em&gt;1.0f-&amp;gt;0.0f&lt;/em&gt; and &lt;em&gt;0.0f-&amp;gt;1.0f&lt;/em&gt;, respectively). Simultaneously, their 3D transforms change to rotate. (Again, don&amp;#39;t worry about the transform&amp;#39;s implementation too much if you don&amp;#39;t want to.)&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    [UIView animateWithDuration:self.transitionDuration
                     animations:
     ^{
         fromView.alpha = 0.0f;
         fromView.layer.transform = [self rotatedLeftToX:offsetX];

         toView.alpha = 1.0f;
         toView.layer.transform = CATransform3DIdentity;
     }

...

- (CATransform3D)rotatedLeftToX:(CGFloat)offsetX {
    CATransform3D rotateNegatively = CATransform3DMakeRotation(-M_PI_2, 0, 1, 0);
    CATransform3D moveLeft = CATransform3DMakeTranslation(-offsetX, 0, 0);
    return CATransform3DConcat(rotateNegatively, moveLeft);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Completion block&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;STPTransition&lt;/em&gt;&amp;#39;s animate method has one more argument: &lt;em&gt;onCompletion&lt;/em&gt;. It is a completion block that we need to execute when we&amp;#39;re done animating, so some automatic cleanup (like calling &lt;em&gt;viewDidAppear:&lt;/em&gt; and &lt;em&gt;viewDidDisappear:&lt;/em&gt; on the controllers involved; seems useful, right?) can happen. Let&amp;#39;s execute it in the animation&amp;#39;s completion block. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;                completion:
^(BOOL finished) {
         onCompletion(finished);

         fromView.alpha = 1.0f;
         toView.alpha = 1.0f;

         fromView.layer.transform = CATransform3DIdentity;
         toView.layer.transform = CATransform3DIdentity;
}];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Note: It also seems like good manners to clean up after ourselves and change the transforms and alphas back to what they were before. We don&amp;#39;t want our views to have a hangover. Nobody likes hangovers.&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;Push, Mrs. Johnson, push&lt;/h3&gt;

&lt;p&gt;It&amp;#39;s time to see what we built. Using our newly created &lt;em&gt;STPRotateFadeTransition&lt;/em&gt; is as simple as this.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[self.navigationController pushViewController:secondViewController
                              usingTransition:[STPRotateFadeTransition new]];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;&lt;img class=&quot;centered&quot; src=&quot;/media/2014-06-01-pushing-a-transition/spin-regular.gif&quot; alt=&quot;&quot; /&gt;
 &lt;/div&gt;

&lt;p&gt;There we have it. A reusable custom transition, decoupled from our view controller code. And we really didn&amp;#39;t need to create any extra files along the way.&lt;/p&gt;

&lt;p&gt;Next part: &lt;a href=&quot;../putting-a-transition-into-reverse-gear/&quot;&gt;Putting a transition into reverse gear&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If you liked what you read here, &lt;a href=&quot;https://twitter.com/stepanhruda&quot;&gt;follow me on Twitter&lt;/a&gt;.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Complete transition&amp;#39;s code for reference:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;// STPRotateFadeTransition.h

@interface STPRotateFadeTransition : STPTransition

@end

// STPRotateFadeTransition.m

#import &amp;quot;STPRotateFadeTransition.h&amp;quot;

@implementation STPRotateFadeTransition 

- (NSTimeInterval)transitionDuration {
    return 0.5f;
}

- (void)animateFromView:(UIView *)fromView
                 toView:(UIView *)toView
        inContainerView:(UIView *)containerView
    executeOnCompletion:(void (^)(BOOL))onCompletion {
    toView.alpha = 0.0f;

    CGFloat offsetX = CGRectGetWidth(containerView.bounds) / 2.5f;

    toView.layer.transform = [self rotatedRightToX:offsetX];

    [containerView addSubview:toView];

    [UIView animateWithDuration:self.transitionDuration
                     animations:
     ^{
         fromView.alpha = 0.0f;
         toView.alpha = 1.0f;

         fromView.layer.transform = [self rotatedLeftToX:offsetX];
         toView.layer.transform = CATransform3DIdentity;
     }
                     completion:
     ^(BOOL finished) {
         onCompletion(finished);

         fromView.alpha = 1.0f;
         toView.alpha = 1.0f;

         fromView.layer.transform = CATransform3DIdentity;
         toView.layer.transform = CATransform3DIdentity;
     }];
}

- (CATransform3D)rotatedLeftToX:(CGFloat)offsetX {
    CATransform3D rotateNegatively = CATransform3DMakeRotation(-M_PI_2, 0, 1, 0);
    CATransform3D moveLeft = CATransform3DMakeTranslation(-offsetX, 0, 0);
    return CATransform3DConcat(rotateNegatively, moveLeft);
}

- (CATransform3D)rotatedRightToX:(CGFloat)offsetX {
    CATransform3D rotatePositively = CATransform3DMakeRotation(M_PI_2, 0, 1, 0);
    CATransform3D moveRight = CATransform3DMakeTranslation(offsetX, 0, 0);
    return CATransform3DConcat(rotatePositively, moveRight);
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Note: If you try to use this exact example transition, make sure your view controllers&amp;#39; background colors are set to &lt;strong&gt;clearColor&lt;/strong&gt; and the navigation controller handles your background instead. Otherwise the view controller background will rotate with everything else, which doesn&amp;#39;t look that good. There are number of ways to approach this, but none of this has much to do with what this article is about.&lt;/em&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 01 Jun 2014 00:00:00 -0400</pubDate>
        <link>http://www.stepan.technology/articles/pushing-a-transition</link>
        <guid isPermaLink="true">http://www.stepan.technology/articles/pushing-a-transition</guid>
      </item>
    
      <item>
        <title>Transition with STPTransitions</title>
        <description>&lt;p&gt;iOS 7 SDK has been around for more than a year now. Among other things, UIKit now allows us to completely (well, almost, more on that later) customize transitions as well as make them interactively react to the user&amp;#39;s finger gestures. Chances that you already wrote some inter-controller animation sweetness should be pretty high. Unless you live in &lt;em&gt;Backwardcompatibilitown&lt;/em&gt;.&lt;/p&gt;

&lt;h3&gt;The catch&lt;/h3&gt;

&lt;p&gt;Of course, there has to be a catch. Honestly, the transitioning API is unnecessarily verbose and a bit too abstract. I&amp;#39;m not a huge fan.&lt;/p&gt;

&lt;p&gt;On top of my complaining, I wrote a wrapper called &lt;a href=&quot;http://github.com/stepanhruda/STPTransitions&quot;&gt;STPTransitions&lt;/a&gt; that makes it easier to animate all of your wonderfully lickable controllers. We have been using it in production for several months now, and I am quite fond of the resulting architecture improvements and code cleanliness. &lt;em&gt;STPTransitions&lt;/em&gt; now also allows you to make your transitions &lt;em&gt;interactive&lt;/em&gt; in just a couple of lines of code.&lt;/p&gt;

&lt;p&gt;I wrote a short series about how I think you should be writing your transitioning code.&lt;/p&gt;

&lt;p&gt;Part 1: &lt;a href=&quot;../pushing-a-transition&quot;&gt;Pushing a transition&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Part 2: &lt;a href=&quot;../putting-a-transition-into-reverse-gear&quot;&gt;Putting a transition into reverse gear&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Part 3: &lt;a href=&quot;../gettin-interactive&quot;&gt;Gettin&amp;#39; interactive&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Part 4: &lt;a href=&quot;../presented-and-child-view-controllers&quot;&gt;Presented and child view controllers&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Part 5: &lt;a href=&quot;../prototyping-transitions&quot;&gt;Prototyping transitions&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If you liked what you read here, &lt;a href=&quot;https://twitter.com/stepanhruda&quot;&gt;follow me on Twitter&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Sat, 31 May 2014 00:00:00 -0400</pubDate>
        <link>http://www.stepan.technology/articles/transition-with-stptransitions</link>
        <guid isPermaLink="true">http://www.stepan.technology/articles/transition-with-stptransitions</guid>
      </item>
    
  </channel>
</rss>
