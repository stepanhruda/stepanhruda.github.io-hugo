<!DOCTYPE html>
<html>
<head>
	<link href="http://gmpg.org/xfn/11" rel="profile">
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<link rel="canonical" href="http://www.stepan.technology/articles/gettin-interactive" />
	<meta name="description" content="Putting the easy into easy transitioning" />
	<meta property="og:description" content="Putting the easy into easy transitioning" />
	<meta itemprop="image" content="http://www.stepan.technology/assets/images/icon.jpeg" />
	<meta property="og:image" content="http://www.stepan.technology/assets/images/icon.jpeg" />
	<meta property="og:title" content="Part 3: Gettin' interactive" />
	<meta property="og:type" content="article" />
	<meta property="og:url" content="http://www.stepan.technology/articles/gettin-interactive" />
	<meta property="og:site_name" content="Stepan.Technology" />
	<title>Part 3: Gettin' interactive &middot; Stepan.Technology</title>
	<meta name="mobile-web-app-capable" content="yes">
	<meta name="HandheldFriendly" content="True" />
	<meta name="MobileOptimized" content="320" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<link rel="stylesheet" type="text/css" media="only screen and (min-width: 1001px)" href="/assets/css/desktop.css" />
	<link rel="stylesheet" type="text/css" media="only screen and (max-width: 1000px)" href="/assets/css/mobile.css" />
	<link href="/assets/css/genericons.css" type="text/css" rel="stylesheet" />
	<link href="/assets/css/syntax.css" type="text/css" rel="stylesheet" />
	<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">
	<link rel="apple-touch-icon" href="http://www.stepan.technology/assets/images/icon.jpeg">
	<link rel="shortcut icon" href="http://www.stepan.technology/assets/images/favicon.ico">
	<link rel="alternate" type="application/rss+xml" title="RSS" href="http://www.stepan.technology/atom.xml">
</head>
<body>
	<header class="clean" style="background-image: url(/assets/images/cover.jpg);height: 350px;">
	
	<!--<label class="menu" for="_1">
	<span class="genericon genericon-menu"></span>
</label>
<input id="_1" type="checkbox">
<div class="menu-content">
	<div class="menu" style="background-color: #777; z-index: -1;"></div>
	
</div>-->
<div class="social-links">
	
	<a href="https://twitter.com/stepanhruda" target="_blank" title="stepanhruda on Twitter"><span class="genericon genericon-twitter"></span></a>
	
	<a href="https://github.com/stepanhruda" target="_blank" title="stepanhruda on GitHub"><span class="genericon genericon-github"></span></a>
	
	<a href="http://www.stepan.technology/atom.xml" target="_blank" title="RSS feed"><span class="genericon genericon-feed"></span></a>
	
</div>
	<div id="post-title">
		<a href="http://www.stepan.technology">
			<h3>Stepan.Technology</h3>
		</a>
	</div>
	<div id="post-info">
		<h1>Part 3: Gettin' interactive</h1>
		
			<h2>Putting the easy into easy transitioning</h2>
		
		<a class="site-title" href="https://twitter.com/stepanhruda"><img src="/assets/images/icon.jpeg" class="site-icon-small">Stepan Hruda</a> on 03 June 2014
	</div>
	<div id="nav-icon" style="bottom: 60px;">
		<a class="scroll" data-speed="1000" href="#article"><span class="genericon genericon-expand"></span></a>
	</div>
</header>
<div id="article">
	<blockquote>
<p>This article is part of the <a href="../transition-with-stptransitions/">Transition with STPTransitions</a> series.</p>
</blockquote>

<p>In the <a href="../putting-a-transition-into-reverse-gear/">second article</a> we made our transition able to animate in both directions. However, the user usually gets a much better experience if a transition tracks their finger movement instead of animating in a chunk. If done correctly, it makes them feel they are in charge of what&#39;s happening on screen, allows them to cancel the animation (and go back), and other good things.</p>

<h3>How to STPTransition</h3>

<p>A transition becomes interactive when it gets attached to a gesture recognizer (there&#39;s a category adding a <em>stp_transition</em> property). On top of that, there are a handful of block properties on the <em>STPTransition</em> instance that we need to implement to achieve finger tracking.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">@property (nonatomic, copy) void (^onGestureTriggered)(STPTransition *transition, UIGestureRecognizer *recognizer);

@property (nonatomic, copy) CGFloat (^completionPercentageForGestureRecognizerState)(UIGestureRecognizer *recognizer);

@property (nonatomic, copy) BOOL (^shouldCompleteTransitionOnGestureEnded)(UIGestureRecognizer *recognizer, CGFloat completion);
</code></pre></div>
<h3>Gesture recognizer</h3>

<p>Let&#39;s start with creating a transition and attaching it to a gesture recognizer. Assuming the user can initiate the gesture anywhere on screen, we&#39;ll just add the recognizer to our application&#39;s <em>keyWindow</em>. For the recognizer, we&#39;ll use <em>UIPanGestureRecognizer</em>, because we want to react do dragging.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">- (void)viewDidLoad {
    [super viewDidLoad];
    ...
    [self setUpGestureRecognizer];
}

- (void)setUpGestureRecognizer {
    STPTransition *transition = [STPRotateFadeTransition new];
    transition.reverseTransition = [STPRotateFadeTransition new];

    [self addGestureRecognizerForTransition:transition];
}

- (void)addGestureRecognizerForTransition:(STPTransition *)transition {
    UIPanGestureRecognizer *recognizer = [UIPanGestureRecognizer new];
    [UIApplication.sharedApplication.keyWindow addGestureRecognizer:recognizer];
    recognizer.stp_transition = transition;
}
</code></pre></div>
<blockquote>
<p>Important note: You shouldn&#39;t be using this gesture recognizer for anything else. It also gets automatically removed from its view after a successful transition. Keeping it attached would mean trouble.</p>
</blockquote>

<h3>Triggering the gesture</h3>

<p>In <em>onGestureTriggered</em> we generally want to tell the controller in what way we&#39;d like the transition to happen. This is the equivalent of using the transition without any interactivity (e.g. pushing in a button action method), except it is wrapped in a conditional block that only gets triggered by the gesture.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">__weak __typeof(self) weakSelf = self;
transition.onGestureTriggered = ^(STPTransition *transition, UIGestureRecognizer *recognizer) {
    [weakSelf.navigationController pushViewController:[STPSecondViewController new]
                                      usingTransition:transition];
};
</code></pre></div>
<p><em>Note: Technically, your controller could own your transition (it could own a view that owns the recognizer that owns the transition), so we should use <strong><em>weakSelf</em></strong> to be safe here.</em></p>

<h3>Tracking the gesture</h3>

<p><em>completionPercentageForGestureRecognizerState</em> does the heavy lifting (if you can even call it heavy lifting). It gives us the recognizer&#39;s state and we need to reply with how it corresponds to the progress of the animation on a scale from 0 (initial state) to 1 (animated all the way).</p>

<p>Let&#39;s say that to get to 100%, the user has to slide halfway across the screen. In our case, we also only track movement on the <em>x</em> axis, since our animation doesn&#39;t happen on the <em>y</em> axis at all.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">transition.completionPercentageForGestureRecognizerState = ^CGFloat (UIGestureRecognizer *recognizer) {
    UIPanGestureRecognizer *panGestureRecognizer = (UIPanGestureRecognizer *)recognizer;
    CGPoint translation = [panGestureRecognizer translationInView:recognizer.view];
    CGFloat completion = (2.0f * -translation.x) / CGRectGetWidth(recognizer.view.frame);
    return completion;
};
</code></pre></div>
<h3>Ending the gesture</h3>

<p><em>shouldCompleteTransitionOnGestureEnded</em> asks us what happens when a detected gesture ends. We have two choices â€“ either we return <em>YES</em> and the transition finishes and goes to the <em>to</em> view controller, or we return <em>NO</em>, the transition gets cancelled and we return to where we started (the <em>from</em> view controller).</p>

<p>There are a number of smart fine-tunings you can do here, but for simplicity&#39;s sake, we&#39;ll finish the transition if the user dragged more than 40% of the way.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">transition.shouldCompleteTransitionOnGestureEnded = ^BOOL (UIGestureRecognizer *recognizer, CGFloat completion) {
    return completion &gt; 0.4f;
};
</code></pre></div>
<h3>Checkpoint</h3>

<p>Let&#39;s see what we have so far.</p>

<div><img class="centered" src="/media/2014-06-03-gettin-interactive/interactive-forward.gif" alt="" />
 </div>

<p>Not bad for a couple of lines of code, right? If you stop dragging &lt;40% of the way, the controller automatically returns where it started. Otherwise, the transition gets finished.</p>

<p>However, if we go there and back and try to use the gesture again, it won&#39;t work.</p>

<div><img class="centered" src="/media/2014-06-03-gettin-interactive/interactive-forward-broken.gif" alt="Why u no work?" />
<blockquote style="border-left: 10px solid #D5D5D5;">Why u no work?</blockquote> </div>

<p>The gesture recognizer gets removed after it&#39;s been used for a successful transition, remember? It is easy enough to track down when we return to the first screen again, and repeat the whole gesture recognizer dance.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">- (void)setUpGestureRecognizer {
    STPTransition *transition = [STPRotateFadeTransition new];
    transition.reverseTransition = [STPRotateFadeTransition new];

    [self setUpForwardTransition:transition];
    [self setUpReverseTransition:transition.reverseTransition];
}

- (void)setUpReverseTransition:(STPTransition *)transition {
    transition.onCompletion = ^(STPTransition *transition, BOOL transitionWasCompleted) {
        if (transitionWasCompleted) {
            [weakSelf setUpGestureRecognizer];
        }
    };
}
</code></pre></div>
<h3>Interacting back</h3>

<p>For our final trick, we&#39;ll make the gesture work for the reverse transition, so the user can freely drag there and back from either screen. It&#39;s almost like if they were dragging a scroll view, while they are in fact switching between controllers in a navigation stack!</p>

<p>We extend our existing <em>setUpReverseTransition:</em> method with a setup very similar to what we already have for the forward transition, with two small differences:</p>

<ul>
<li>when the gesture gets triggered, we want to pop the controller, not push it</li>
<li>the gesture recognizer&#39;s translation is now a positive value (user&#39;s dragging the other way), so we lose the negative sign</li>
</ul>
<div class="highlight"><pre><code class="language-text" data-lang="text">- (void)setUpReverseTransition:(STPTransition *)transition {
    __weak __typeof(self) weakSelf = self;
    transition.onGestureTriggered = ^(STPTransition *transition, UIGestureRecognizer *recognizer) {
        [weakSelf.navigationController popViewControllerAnimated:YES];
    };

    transition.completionPercentageForGestureRecognizerState = ^CGFloat (UIGestureRecognizer *recognizer) {
        UIPanGestureRecognizer *panGestureRecognizer = (UIPanGestureRecognizer *)recognizer;
        CGPoint translation = [panGestureRecognizer translationInView:recognizer.view];
        CGFloat completion = (2.0f * translation.x) / CGRectGetWidth(recognizer.view.frame);
        return completion;
    };

    transition.shouldCompleteTransitionOnGestureEnded = ^BOOL (UIGestureRecognizer *recognizer, CGFloat completion) {
        return completion &gt; 0.4f;
    };

    transition.onCompletion = ^(STPTransition *transition, BOOL transitionWasCompleted) {
        if (transitionWasCompleted) {
            [weakSelf setUpGestureRecognizer];
        }
    };
}
</code></pre></div>
<p>Additionaly, we need to make sure a gesture recognizer that can track the view exists. It seems like a good idea to add it when the first transition finishes, because that&#39;s the first moment the user could possibly drag back.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">- (void)setUpForwardTransition:(STPTransition *)transition {
    ...
    transition.onCompletion = ^(STPTransition *transition, BOOL transitionWasCompleted) {
        if (transitionWasCompleted) {
            [weakSelf addGestureRecognizerForTransition:transition.reverseTransition];
        }
    };

}
</code></pre></div>
<div><img class="centered" src="/media/2014-06-03-gettin-interactive/interactive-both-ways.gif" alt="Finally we can spin it properly!" />
<blockquote style="border-left: 10px solid #D5D5D5;">Finally we can spin it properly!</blockquote> </div>

<p>Next part: <a href="../presented-and-child-view-controllers/">Presented and child view controllers</a></p>

<p>If you liked what you read here, <a href="https://twitter.com/stepanhruda">follow me on Twitter</a>.</p>

<hr>

<p>All written view controller code for reference:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">- (void)viewDidLoad {
    [super viewDidLoad];
    ...
    [self setUpGestureRecognizer];
}

- (void)setUpGestureRecognizer {
    STPTransition *transition = [STPRotateFadeTransition new];
    transition.reverseTransition = [STPRotateFadeTransition new];

    [self setUpForwardTransition:transition];
    [self setUpReverseTransition:transition.reverseTransition];
}

- (void)setUpForwardTransition:(STPTransition *)transition {
    [self addGestureRecognizerForTransition:transition];

    __weak __typeof(self) weakSelf = self;
    transition.onGestureTriggered = ^(STPTransition *transition, UIGestureRecognizer *recognizer) {
        [weakSelf.navigationController pushViewController:[STPSecondViewController new]
                                          usingTransition:transition];
    };

    transition.completionPercentageForGestureRecognizerState = ^CGFloat (UIGestureRecognizer *recognizer) {
        UIPanGestureRecognizer *panGestureRecognizer = (UIPanGestureRecognizer *)recognizer;
        CGPoint translation = [panGestureRecognizer translationInView:recognizer.view];
        CGFloat completion = (2.0f * -translation.x) / CGRectGetWidth(recognizer.view.frame);
        return completion;
    };

    transition.shouldCompleteTransitionOnGestureEnded = ^BOOL (UIGestureRecognizer *recognizer, CGFloat completion) {
        return completion &gt; 0.4f;
    };

    transition.onCompletion = ^(STPTransition *transition, BOOL transitionWasCompleted) {
        if (transitionWasCompleted) {
            [weakSelf addGestureRecognizerForTransition:transition.reverseTransition];
        }
    };
}

- (void)setUpReverseTransition:(STPTransition *)transition {
    __weak __typeof(self) weakSelf = self;
    transition.onGestureTriggered = ^(STPTransition *transition, UIGestureRecognizer *recognizer) {
        [weakSelf.navigationController popViewControllerAnimated:YES];
    };

    transition.completionPercentageForGestureRecognizerState = ^CGFloat (UIGestureRecognizer *recognizer) {
        UIPanGestureRecognizer *panGestureRecognizer = (UIPanGestureRecognizer *)recognizer;
        CGPoint translation = [panGestureRecognizer translationInView:recognizer.view];
        CGFloat completion = (2.0f * translation.x) / CGRectGetWidth(recognizer.view.frame);
        return completion;
    };

    transition.shouldCompleteTransitionOnGestureEnded = ^BOOL (UIGestureRecognizer *recognizer, CGFloat completion) {
        return completion &gt; 0.4f;
    };

    transition.onCompletion = ^(STPTransition *transition, BOOL transitionWasCompleted) {
        if (transitionWasCompleted) {
            [weakSelf setUpGestureRecognizer];
        }
    };
}

- (void)addGestureRecognizerForTransition:(STPTransition *)transition {
    UIPanGestureRecognizer *recognizer = [UIPanGestureRecognizer new];
    [UIApplication.sharedApplication.keyWindow addGestureRecognizer:recognizer];
    recognizer.stp_transition = transition;
}
</code></pre></div>
</div>

<footer class="clean" style="background-image: url(/assets/images/cover.jpg);height: 75%; min-height: 500px;">
	<div id="nav-icon" style="top: 25px;">
		<a class="scroll" data-speed="1000" href="#article"><span class="genericon genericon-collapse"></span></a>
	</div>
	<div id="post-info">
		<h3>Featured post</h3>
		<a href="/articles/prototyping-transitions">
			<h1>Part 5: Prototyping transitions</h1>
			
				<h2>Putting the easy into easy transitioning</h2>
			
		</a>
	</div>
	<p class="copyright">&copy;2014, <a href="http://www.stepan.technology" target="_blank">Stepan Hruda</a>. <a href="http://creativecommons.org/licenses/by-nc/2.5" target="_blank">Some rights reserved</a>.</p>
</footer>

<script src="/assets/js/smooth-scroll.js"></script>
</body>
</html>